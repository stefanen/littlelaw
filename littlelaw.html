<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Little's Law simulation</title>
    <style></style>
</head>

<body>
<canvas id="gameCanvas"></canvas>

<div style="background-color: lightgreen">
    <label><b>Customer arrival process</b></label>
    <p id="ARRIVAL_AREA_DATA"></p>
    <p id="ARRIVAL_AREA_STATS"></p>
</div>

<div style="background-color: orange">
    <label><b>Queue area (waiting room)</b></label>
    <p id="QUEUE_AREA_DATA"></p>
    <p id="QUEUE_AREA_STATS"></p>
</div>

<div style="background-color: yellow">
    <label><b>Servicing process</b></label>
    <p id="SERVICE_AREA_DATA"></p>
    <p id="SERVICE_AREA_STATS"></p>
</div>

<p><label><b>Simulation parameters</b></label></p>
<p><label style="width: 300px; display:inline-block">Average service time (seconds) (W) </label><input type="text"
                                                                                                       id="AVERAGE_SERVICE_TIME_W"
                                                                                                       value="2"></p>
<p><label style="width: 300px; display:inline-block">Arrival rate intensity (customers/second) (λ) </label><input
        type="text" id="ARRIVAL_RATE_INTENSITY_LAMBDA" value="3"></p>
<p><label style="width: 300px; display:inline-block">Service worker count (k)</label><input type="text"
                                                                                            id="SERVICE_LANE_COUNT_K"
                                                                                            value="7"></p>
<button onclick="simulation.startSimulation()">Restart simulation</button>

<hr></hr>


<div style="font-style: italic">
    This simulation uses the queue model M/M/k, see: https://en.wikipedia.org/wiki/M/M/c_queue. In short, this model consists of 2 parts:
    <br>
    1) A customer arrival process. This random process is modelled by a Poisson-λ process
    <br>
    2) A servicing process. A customer arriving to the service area will be served by one of k servers, or placed into a waiting queue if no servers are available. The service time of a single customer is random and follows a Exp(1/W) distribution
    <br>
    <br>
</div>


<br>
<p id="summary"></p>
<br>
<script>
    //This demo is not meant to be a reliable simulation (we use javascripts unreliable timers) ... just a proof of concept

    var simulation = new function () {
        const self = this;

        self.intervals = [];
        self.timeouts = [];

        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const CANVAS_PADDING = 10;

        const SERVICE_START_X = 400;

        const BALL_SIZE = 10;
        const BALL_MOVEMENT_PIXEL_COUNT_PER_UPDATE = 5;
        const BALL_UPDATE_FREQUENCY_MS = 20;
        const BALL_SPEED_PIXEL_PER_SECOND = BALL_UPDATE_FREQUENCY_MS * BALL_MOVEMENT_PIXEL_COUNT_PER_UPDATE;
        const BALL_INITIAL_Y_COORD = CANVAS_HEIGHT - 50;
        const BALL_FINAL_X_COORD = SERVICE_START_X + 10;

        const canvas = document.getElementById("gameCanvas");
        const context = canvas.getContext("2d");
        const startEpochMs = new Date().getTime();

        function initCanvas() {
            //TODO make prettier
            canvas.setAttribute("height", CANVAS_HEIGHT)
            canvas.setAttribute("width", CANVAS_WIDTH)
            context.moveTo(0.5 + SERVICE_START_X, CANVAS_PADDING);
            context.lineTo(0.5 + SERVICE_START_X, CANVAS_HEIGHT + CANVAS_PADDING - 40);
            context.moveTo(0.5 + CANVAS_WIDTH - 40 + CANVAS_PADDING, CANVAS_PADDING);
            context.lineTo(0.5 + CANVAS_WIDTH - 40 + CANVAS_PADDING, CANVAS_HEIGHT + CANVAS_PADDING - 40);
            context.moveTo(CANVAS_PADDING, 0.5 + CANVAS_HEIGHT - 40 + CANVAS_PADDING);
            context.lineTo(CANVAS_WIDTH + CANVAS_PADDING - 40, 0.5 + CANVAS_HEIGHT - 40 + CANVAS_PADDING);
            context.moveTo(CANVAS_PADDING, 0.5 + CANVAS_HEIGHT - 80 + CANVAS_PADDING);
            context.lineTo(CANVAS_WIDTH + CANVAS_PADDING - 40, 0.5 + CANVAS_HEIGHT - 80 + CANVAS_PADDING);

            context.font = "12px Verdana";
            context.fillStyle = "black";
            [...Array(10).keys()].forEach(i => {
                context.fillText(i + "s", CANVAS_WIDTH - 14, 0.5 + CANVAS_HEIGHT - 50 - 100 * i)
            });
            context.fillText("W=", CANVAS_WIDTH - 29, 0.5 + CANVAS_HEIGHT - 50 - BALL_SPEED_PIXEL_PER_SECOND * self.AVERAGE_SERVICE_TIME_W);
            //context.moveTo(BALL_FINAL_X_COORD, BALL_INITIAL_Y_COORD-100);
            //context.lineTo(BALL_FINAL_X_COORD+30, BALL_INITIAL_Y_COORD-100);


            /*
            context.font = "30px Verdana";
            context.fillStyle = "black";
            context.fillText("LITTLE's LAW SIMULATION", CANVAS_WIDTH / 2 - 450, CANVAS_HEIGHT / 2 - 200)

            context.font = "15px Verdana";
            context.fillText("Little's law says that the (long time) average number of self.balls in the yellow lane is L=λ*W", CANVAS_WIDTH / 2 - 350, CANVAS_HEIGHT / 2 - 170)
            context.fillText("The queue-model used here is M/M/∞:", CANVAS_WIDTH / 2 - 350, CANVAS_HEIGHT / 2 - 140)
            context.fillText("Poisson-λ arrival process ", CANVAS_WIDTH / 2 - 350, CANVAS_HEIGHT / 2 - 110)
            context.fillText("Exp(1/W)-distributed (independent) service times", CANVAS_WIDTH / 2 - 350, CANVAS_HEIGHT / 2 - 80)
            context.fillText("Infinite amount of servers (betjäningsstationer), so no waiting queue", CANVAS_WIDTH / 2 - 350, CANVAS_HEIGHT / 2 - 50)

            context.fillText("ARRIVAL PROCESS (green)", CANVAS_WIDTH / 2 - 250, CANVAS_HEIGHT - 80)

            context.rotate(-Math.PI/2);
            context.fillText("SERVICING PROCESS (yellow)", -490, 720)
            context.rotate(Math.PI/2);
    */

            context.strokeStyle = "black";
            context.stroke();

        }

        function updateCanvas() {
            context.fillStyle = "lightgreen";
            context.fillRect(0, canvas.height - 68, canvas.width - 45, 38);

            context.fillStyle = "yellow";
            context.fillRect(SERVICE_START_X + 1, 0, 369, canvas.height - 30);

            context.fillStyle = "orange";
            context.fillRect(SERVICE_START_X - 10, canvas.height - 68, 20, 38);

            /*
            for (var i=1;i<self.SERVICE_LANE_COUNT_K+1; i++) {
                context.moveTo(0.5 + SERVICE_START_X+i*50, CANVAS_PADDING);
                context.lineTo(0.5 + SERVICE_START_X+i*50, CANVAS_HEIGHT + CANVAS_PADDING-40);

            }
                    context.strokeStyle = "black";
            context.stroke();
            */
        }

        function randomExponential(rate, randomUniform) {
            // http://en.wikipedia.org/wiki/Exponential_distribution#Generating_exponential_variates
            rate = rate || 1;

            // Allow to pass a random uniform value or function
            // Default to Math.random()
            var U = randomUniform;
            if (typeof randomUniform === 'function') U = randomUniform();
            if (!U) U = Math.random();

            return -Math.log(U) / rate;
        }

        function getExpRandomExitPosition() {
            return BALL_FINAL_X_COORD + Math.floor(BALL_SPEED_PIXEL_PER_SECOND * randomExponential(1 / self.AVERAGE_SERVICE_TIME_W));

        }

        function generateNewBall() {
            const currentEpochMs = new Date().getTime();
            if (currentEpochMs > self.nextBallCreationEpochMs) {
                self.lastBallCreationEpochMs = currentEpochMs;
                self.nextBallCreationEpochMs = self.lastBallCreationEpochMs + 1000 * randomExponential(self.ARRIVAL_RATE_INTENSITY_LAMBDA)
                self.balls.push(
                    {
                        position: 0,
                        exitPosition: getExpRandomExitPosition(),
                        serviceLane: -1,
                        waitQueueEnterTimeMs: 0,
                        waitQueueExitTimeMs: 0
                    }
                )
            }
        }

        function updateDisplayStats() {
            if (self.doCalculateAverageBallCountStats) {
                var avgQueueWaitTimeMs = Math.round(self.queueWaitTimeStats.reduce((a, b) => a + b, 0) / self.queueWaitTimeStats.length * 100) / 100
                var actualAvgServiceTime=Math.round(self.serviceTimesMsStats.reduce((a, b) => a + b, 0) / self.serviceTimesMsStats.length * 100) / 100;
                var actualAvgArrivalRate=(Math.round((100/BALL_FINAL_X_COORD)*simulation.arrivalAreaCountStats.reduce((a, b) => a + b, 0) / simulation.arrivalAreaCountStats.length * 100) / 100);


                document.getElementById("ARRIVAL_AREA_STATS").innerHTML = `AverageCount=${Math.round(simulation.arrivalAreaCountStats.reduce((a, b) => a + b, 0) / simulation.arrivalAreaCountStats.length * 100) / 100},
                    MaxCount=${Math.max.apply(null, simulation.arrivalAreaCountStats)},
                    AverageArrivalRate=${actualAvgArrivalRate}`

                document.getElementById("QUEUE_AREA_STATS").innerHTML = `AverageCount=${Math.round(simulation.queueAreaCountStats.reduce((a, b) => a + b, 0) / simulation.queueAreaCountStats.length * 100) / 100},
                    MaxCount=${Math.max.apply(null, simulation.queueAreaCountStats)},
                    AverageWaitTimeMs=${avgQueueWaitTimeMs}`

                document.getElementById("SERVICE_AREA_STATS").innerHTML = `AverageCount=${Math.round(simulation.serviceAreaCountStats.reduce((a, b) => a + b, 0) / simulation.serviceAreaCountStats.length * 100) / 100},
                    MaxCount=${Math.max.apply(null, simulation.serviceAreaCountStats)},
                    MaxCapacity=${self.SERVICE_LANE_COUNT_K},
                    AverageServiceTime=${actualAvgServiceTime}`
            }

        }

        function animateBallMovements() {
            updateCanvas();

            var ballCountInService = 0;
            var ballCountWaiting = 0;

            // move the self.balls
            self.balls.forEach(ball => {
                var bx, by;
                if (ball.position < BALL_FINAL_X_COORD) {
                    bx = ball.position
                    by = BALL_INITIAL_Y_COORD;
                    ball.position += BALL_MOVEMENT_PIXEL_COUNT_PER_UPDATE;


                } else {
                    ballCountInService++;
                    if (ball.serviceLane == -1) {
                        var firstFreeLane = [...Array(self.SERVICE_LANE_COUNT_K).keys()].find(p => ("undefined" == typeof self.usedServiceLanes.find(i => i == p)));

                        if (ball.waitQueueEnterTimeMs == 0) {
                            ball.waitQueueEnterTimeMs = (new Date()).getTime();
                        }
                        if (typeof firstFreeLane == "undefined") {
                            ballCountWaiting++;
                            return;
                        }

                        ball.waitQueueExitTimeMs = (new Date()).getTime();

                        //console.log("waitTimeMs:" + (ball.waitQueueExitTimeMs - ball.waitQueueEnterTimeMs));
                        self.queueWaitTimeStats.push((ball.waitQueueExitTimeMs - ball.waitQueueEnterTimeMs));


                        ball.serviceLane = firstFreeLane;
                        self.usedServiceLanes.push(ball.serviceLane);
                    }
                    ball.position += BALL_MOVEMENT_PIXEL_COUNT_PER_UPDATE;


                    const SERVICE_LANE_OFFSET_X = ball.serviceLane * 50;

                    bx = BALL_FINAL_X_COORD + SERVICE_LANE_OFFSET_X;
                    by = BALL_INITIAL_Y_COORD + BALL_FINAL_X_COORD - ball.position;
                }


                if (ball.position <= ball.exitPosition) {
                    context.fillStyle = "blue";
                    context.fillRect(bx - BALL_SIZE / 2, by - BALL_SIZE / 2, BALL_SIZE, BALL_SIZE);
                } else {
                    ballCountInService--;
                    context.fillStyle = "gray";
                    context.fillRect(bx + BALL_SIZE - BALL_SIZE / 2, by - BALL_SIZE / 2, BALL_SIZE, BALL_SIZE);
                    //console.log(ball.position-BALL_FINAL_X_COORD)
                    self.serviceTimesMsStats.push((ball.position - BALL_FINAL_X_COORD) / BALL_SPEED_PIXEL_PER_SECOND)
                    self.usedServiceLanes = self.usedServiceLanes.filter(p => p != ball.serviceLane);
                }
            });

            //draw waiting queue
            if (ballCountWaiting > 0) {
                context.fillStyle = "blue";
                context.fillRect(BALL_FINAL_X_COORD - BALL_SIZE / 2 - BALL_SIZE * ballCountWaiting, BALL_INITIAL_Y_COORD - BALL_SIZE / 2, BALL_SIZE + BALL_SIZE * ballCountWaiting, BALL_SIZE);

            }

            //remove finished self.balls
            self.balls = self.balls.filter(function (ball) {
                return ball.position <= ball.exitPosition
            });


            var ballCountInArrivalArea = self.balls.length - ballCountInService;
            //update display count per area

            if (self.doCalculateAverageBallCountStats) {
                self.arrivalAreaCountStats.push(ballCountInArrivalArea);
                self.queueAreaCountStats.push(ballCountWaiting);
                self.serviceAreaCountStats.push(ballCountInService - ballCountWaiting);
            }

            document.getElementById("ARRIVAL_AREA_DATA").innerHTML = `Current customer count: ${ballCountInArrivalArea}`;
            document.getElementById("QUEUE_AREA_DATA").innerHTML = `Current customer count: ${ballCountWaiting}`;
            document.getElementById("SERVICE_AREA_DATA").innerHTML = `Current customer count: ${ballCountInService - ballCountWaiting}`;


        }

        //setup simulation:

        this.init = function () {
            initCanvas();
            //tableCreate();
        }

        this.startSimulation = function () {
            self.balls = [];

            self.arrivalAreaCountStats = [];
            self.queueAreaCountStats = [];
            self.serviceAreaCountStats = [];

            self.queueWaitTimeStats = [];
            self.serviceTimesMsStats = [];
            self.doCalculateAverageBallCountStats = false;
            self.lastBallCreationEpochMs = startEpochMs;
            self.nextBallCreationEpochMs = self.lastBallCreationEpochMs + 1000 * randomExponential(self.ARRIVAL_RATE_INTENSITY_LAMBDA)
            self.usedServiceLanes = [];
            self.AVERAGE_SERVICE_TIME_W = parseInt(document.getElementById("AVERAGE_SERVICE_TIME_W").value)
            self.ARRIVAL_RATE_INTENSITY_LAMBDA = parseInt(document.getElementById("ARRIVAL_RATE_INTENSITY_LAMBDA").value);
            self.SERVICE_LANE_COUNT_K = parseInt(document.getElementById("SERVICE_LANE_COUNT_K").value);

            document.getElementById("AVERAGE_SERVICE_TIME_W").innerHTML = self.AVERAGE_SERVICE_TIME_W;
            document.getElementById("ARRIVAL_RATE_INTENSITY_LAMBDA").innerHTML = self.ARRIVAL_RATE_INTENSITY_LAMBDA;
            document.getElementById("SERVICE_LANE_COUNT_K").innerHTML = self.SERVICE_LANE_COUNT_K;
            //document.getElementById("LITTLE_LAW_PREDICTED_AVERAGE_BALL_COUNT_IN_SERVICE").innerHTML = self.AVERAGE_SERVICE_TIME_W * self.ARRIVAL_RATE_INTENSITY_LAMBDA;

            document.getElementById("ARRIVAL_AREA_STATS").innerHTML = "";
            document.getElementById("QUEUE_AREA_STATS").innerHTML = "";
            document.getElementById("SERVICE_AREA_STATS").innerHTML = "";

            self.intervals.forEach(p => clearInterval(p));
            self.timeouts.forEach(p => clearTimeout(p));

            updateDisplayStats()
            self.intervals = [
                setInterval(animateBallMovements, 1000 / BALL_UPDATE_FREQUENCY_MS),
                setInterval(generateNewBall, 1000 / BALL_UPDATE_FREQUENCY_MS),
                setInterval(function () {
                    updateDisplayStats()
                }, 5000)
            ];
            self.timeouts = [
                setTimeout(function () {
                    self.doCalculateAverageBallCountStats = true;
                }, 10000)
            ]

        }

    }

    simulation.init();
    simulation.startSimulation();


</script>
</body>

</html>

